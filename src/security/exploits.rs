//! PATH vulnerability exploitability verification.
use std::path::Path;

#[derive(Debug, Clone)]
pub struct ExploitCheckResult {
    pub path: String,
    pub is_exploitable: bool,
    pub found_exploits: Vec<String>,
}

impl ExploitCheckResult {
    pub fn safe(path: impl Into<String>) -> Self {
        Self {
            path: path.into(),
            is_exploitable: false,
            found_exploits: Vec::new(),
        }
    }
    pub fn exploitable(path: impl Into<String>, exploits: Vec<String>) -> Self {
        Self {
            path: path.into(),
            is_exploitable: true,
            found_exploits: exploits,
        }
    }
}

#[derive(Debug, Default)]
pub struct VerificationSummary {
    pub total_checked: usize,
    pub real_threats: usize,
    pub potential_risks: usize,
}

const EXPLOIT_EXTENSIONS: [&str; 4] = [".exe", ".com", ".bat", ".cmd"];

pub fn generate_exploit_paths(path: &str) -> Vec<String> {
    let mut exploits = Vec::new();
    let clean_path = path.trim_matches('"');
    let parts: Vec<&str> = clean_path.split('\\').collect();
    if parts.is_empty() {
        return exploits;
    }
    let mut accumulated = String::new();
    for (i, part) in parts.iter().enumerate() {
        if i > 0 {
            accumulated.push('\\');
        }
        accumulated.push_str(part);
        if i < parts.len() - 1 && part.contains(' ') {
            for ext in &EXPLOIT_EXTENSIONS {
                exploits.push(format!("{}{}", accumulated, ext));
            }
        }
    }
    exploits
}

pub fn check_exploitability(path: &str) -> ExploitCheckResult {
    let exploit_paths = generate_exploit_paths(path);
    let found_exploits: Vec<String> = exploit_paths
        .into_iter()
        .filter(|p| Path::new(p).exists())
        .collect();
    if found_exploits.is_empty() {
        ExploitCheckResult::safe(path)
    } else {
        ExploitCheckResult::exploitable(path, found_exploits)
    }
}

pub fn verify_paths(paths: &[&str]) -> (Vec<ExploitCheckResult>, VerificationSummary) {
    let mut results = Vec::new();
    let mut summary = VerificationSummary {
        total_checked: paths.len(),
        ..Default::default()
    };
    for path in paths {
        let result = check_exploitability(path);
        if result.is_exploitable {
            summary.real_threats += 1;
        } else {
            summary.potential_risks += 1;
        }
        results.push(result);
    }
    (results, summary)
}
